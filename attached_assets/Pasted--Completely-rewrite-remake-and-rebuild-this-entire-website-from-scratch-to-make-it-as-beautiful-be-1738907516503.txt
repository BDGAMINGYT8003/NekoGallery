"Completely rewrite, remake and rebuild this entire website from scratch to make it as beautiful, better and greatest as possible with more pages with features added specifically for the gallery"

<!DOCTYPE html>  <html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Neko Gallery</title>  
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">  
    <style>  
        /* --- CSS Reset and Root Variables --- */  
        :root {  
            --primary-color: #6366f1;  
            --secondary-color: #a855f7;  
            --accent-color: #ec4899;  
            --background-color: #1a1a2e;  
            --card-background-color: rgba(255, 255, 255, 0.1);  
            --text-color-light: #fff;  
            --text-color-dimmed: rgba(255, 255, 255, 0.7);  
            --transition-duration: 0.5s;  
            --error-color: #f44336;  
        }  *, *::before, *::after {
margin: 0;
padding: 0;
box-sizing: border-box;
}

/* --- Body Styles --- */
body {
font-family: 'Poppins', sans-serif;
min-height: 100vh;
background: linear-gradient(135deg, var(--background-color), #16213e);
color: var(--text-color-light);
display: flex;
align-items: center;
justify-content: center;
padding: 1rem;
transition: background-color var(--transition-duration);
flex-direction: column;
}

/* --- Container Styles --- */
.container {
max-width: 800px;
width: 100%;
perspective: 1000px;
margin-bottom: 1rem;
}

/* --- Header Styles --- /
.header {
display: flex;
align-items: center;
justify-content: space-between;
margin-bottom: 1.5rem;
padding: 1rem 2rem;
border-radius: 5px; / Sharper corners /
background-color: var(--card-background-color);
backdrop-filter: blur(8px);
border: 1px solid rgba(255, 255, 255, 0.1);
transform-style: preserve-3d;
transition: transform var(--transition-duration) ease;
position: relative; / To position error message /
overflow: hidden; / Clip any content that goes outside, like error message */
}

.header:hover {
transform: translateZ(20px);
}

.header-title {
font-size: 2rem;
background: linear-gradient(to right, var(--primary-color), var(--accent-color));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
position: relative;
z-index: 1; /* Ensure title is behind error message when it shows */
}

.header-title::after {
content: '';
position: absolute;
bottom: -5px;
left: 0;
width: 0;
height: 2px;
background: linear-gradient(to right, var(--primary-color), var(--accent-color));
transition: width var(--transition-duration) ease;
}

.header:hover .header-title::after {
width: 100%;
}

/* --- Button Styles --- /
.new-art-button {
background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
border: none;
padding: 0.7rem 1.5rem;
color: var(--text-color-light);
border-radius: 8px; / Sharper corners /
font-size: 1rem;
cursor: pointer;
transition: all var(--transition-duration) cubic-bezier(0.4, 0, 0.2, 1);
position: relative;
overflow: hidden;
box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
z-index: 1; / Ensure button is behind error message when it shows */
}

.new-art-button::before {
content: '';
position: absolute;
top: 50%;
left: 50%;
width: 0;
height: 0;
background: rgba(255, 255, 255, 0.2);
border-radius: 50%;
transform: translate(-50%, -50%);
transition: width calc(var(--transition-duration) * 2) ease, height calc(var(--transition-duration) * 2) ease;
}

.new-art-button:hover::before {
width: 300px;
height: 300px;
}

.new-art-button:hover {
transform: translateY(-3px) scale(1.05);
box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
}

.new-art-button:active {
transform: translateY(1px) scale(0.98);
}

/* --- Gallery Card Styles --- /
.gallery-card {
background-color: var(--card-background-color);
backdrop-filter: blur(12px);
border-radius: 5px; / Sharper corners */
padding: 1.5rem;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
border: 1px solid rgba(255, 255, 255, 0.1);
transform-style: preserve-3d;
transition: transform calc(var(--transition-duration) * 1.5) cubic-bezier(0.4, 0, 0.2, 1);
}

.gallery-card:hover {
transform: translateZ(30px);
}

/* --- Neko Wrapper Styles --- /
.neko-wrapper {
position: relative;
border-radius: 4px; / Sharper corners */
overflow: hidden;
transform-style: preserve-3d;
transition: transform var(--transition-duration) ease;
width: 100%;
aspect-ratio: 16/9;
background-color: rgba(0, 0, 0, 0.2);
}

/* --- Image and Skeleton Styles --- /
.skeleton,
.neko-image {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
object-fit: contain;
border-radius: 4px; / Sharper corners */
transition: transform var(--transition-duration) ease, opacity var(--transition-duration) ease;
background-color: rgba(0, 0, 0, 0.2);
}

.neko-image:hover {
transform: scale(1.03);
}

.skeleton {
background: linear-gradient(90deg,
rgba(45, 45, 74, 0.8) 25%,
rgba(58, 58, 90, 0.8) 50%,
rgba(45, 45, 74, 0.8) 75%);
background-size: 200% 100%;
animation: shimmer 2s infinite linear;
animation-duration: 2s;
}

@keyframes shimmer {
0% { background-position: 200% 0; }
100% { background-position: -200% 0; }
}

/* --- Loading Indicator Styles --- */
.loading {
display: none;
text-align: center;
margin-top: 1rem;
font-size: 1rem;
color: rgba(255, 255, 255, 0.9);
animation: pulse 2s infinite;
animation-duration: 2s;
}

@keyframes pulse {
0%, 100% { opacity: 0.6; }
50% { opacity: 1; }
}

/* --- Credit Styles --- */
.credit {
text-align: center;
margin-top: 1.5rem;
font-size: 0.9rem;
color: var(--text-color-dimmed);
transition: color var(--transition-duration) ease;
margin-bottom: 1rem;
}

.credit:hover {
color: var(--text-color-light);
}

/* --- Error Message Styles --- /
.error-message {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: var(--error-color);
color: var(--text-color-light);
border-radius: 5px; / Sharper corners /
backdrop-filter: blur(8px);
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
display: none;
z-index: 2; / Higher z-index to be on top of header content /
opacity: 0;
transition: opacity var(--transition-duration) ease;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
padding: 1rem 2rem; / Wider horizontal padding /
font-size: 1.1rem; / Slightly reduced font size for balance /
line-height: 1.4; / Improved line height for readability */
}

.error-message.show {
display: flex;
opacity: 1;
}

.error-message::before {
content: '⚠️';
font-size: 2.5rem; /* Adjusted icon size /
margin-bottom: 0.7rem; / Adjusted margin below icon */
display: block;
}

/* --- Zoom Controls Styles --- */
.zoom-controls {
position: absolute;
bottom: 1rem;
left: 50%;
transform: translateX(-50%);
display: flex;
gap: 0.5rem;
opacity: 0;
transition: opacity var(--transition-duration) ease;
z-index: 10;
}

.neko-wrapper:hover .zoom-controls {
opacity: 1;
}

.zoom-button {
background-color: rgba(0, 0, 0, 0.7);
border: 1px solid rgba(255, 255, 255, 0.1);
color: var(--text-color-light);
width: 30px;
height: 30px;
border-radius: 50%; /* Kept round for circular buttons */
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
backdrop-filter: blur(8px);
transition: all var(--transition-duration) ease;
}

.zoom-button:hover {
background-color: rgba(0, 0, 0, 0.9);
transform: scale(1.1);
}

/* --- Coming Soon Button Styles --- /
.coming-soon-button {
background: var(--accent-color);
border: none;
padding: 0.7rem 1.5rem;
color: var(--text-color-light);
border-radius: 8px; / Sharper corners */
font-size: 1rem;
cursor: pointer;
transition: all var(--transition-duration) cubic-bezier(0.4, 0, 0.2, 1);
box-shadow: 0 4px 15px rgba(236, 72, 153, 0.5);
display: block;
margin-left: auto;
margin-right: auto;
margin-bottom: 2rem;
max-width: 200px;
text-align: center;
}

.coming-soon-button:hover {
transform: translateY(-3px) scale(1.05);
box-shadow: 0 8px 25px rgba(236, 72, 153, 0.6);
}

.coming-soon-button:active {
transform: translateY(1px) scale(0.98);
}
</style>

</head>  
<body>  
    <div class="container">  
        <header class="header">  
            <h1 class="header-title">Neko Gallery</h1>  
            <button class="new-art-button" id="newArtButton">✨ New Art</button>  
            <div class="error-message" id="errorMessage">  
                Failed to load unique artwork. Please try again later.  
            </div>  
        </header>  
        <section class="gallery-card">  
            <div id="imageContent">  
                <div class="neko-wrapper">  
                    <div class="skeleton" id="skeleton"></div>  
                    <img class="neko-image" id="artImage" src="" alt="Anime Artwork" style="display: none;">  
                    <div class="zoom-controls">  
                        <button class="zoom-button zoom-out-button">-</button>  
                        <button class="zoom-button zoom-in-button">+</button>  
                    </div>  
                </div>  
            </div>  
            <p class="loading">Loading Artwork...</p>  
        </section>  
        <footer class="credit">Made with ❤️ by Anime Lovers</footer>  
        <button class="coming-soon-button" onclick="location.href='soon.html'">Coming Soon</button>  
    </div>  <script>  
    document.addEventListener('DOMContentLoaded', () => {  
        // --- API and Category Setup ---  
        const nsfwApiCategories = [  
            "anal", "ass", "blowjob", "breeding", "buttplug", "cages",  
            "ecchi", "feet", "fo", "gif", "hentai", "legs",  
            "masturbation", "milf", "neko", "paizuri", "petgirls",  
            "pierced", "selfie", "smothering", "socks", "vagina", "yuri"  
        ];  
        const waifuPicsApiCategories = ["waifu", "neko", "blowjob"];  
        const allApiCategories = [...nsfwApiCategories, ...waifuPicsApiCategories.map(cat => `waifu_${cat}`)];  
  
        const apiEndpoints = {  
            nsfw_api: 'https://api.n-sfw.com/nsfw/',  
            waifu_pics_api: 'https://api.waifu.pics/nsfw/',  
            nekos_moe_api: 'https://nekos.moe/api/v1/random/image'  
        };  
  
        const apiSources = ['nsfw_api', 'waifu_pics_api', 'nekos_moe_api'];  
  
        // --- Preloading System ---  
        const preloadQueue = [];  
        const preloadQueueLimit = 5;  
        let isPreloading = false;  
        let pendingDisplay = false;  
        const displayedImageUrls = new Set();  
  
        // --- DOM Elements ---  
        const artImageElement = document.getElementById('artImage');  
        const skeletonElement = document.getElementById('skeleton');  
        const imageContentElement = document.getElementById('imageContent');  
        const loadingElement = document.querySelector('.loading');  
        const errorMessageElement = document.getElementById('errorMessage');  
        const newArtButton = document.getElementById('newArtButton');  
        const zoomInButton = document.querySelector('.zoom-in-button');  
        const zoomOutButton = document.querySelector('.zoom-out-button');  
        const nekoWrapper = document.querySelector('.neko-wrapper');  
        const transitionDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--transition-duration'));  
  
        let currentZoom = 1;  
        let isLoading = false;  
        let initialImageDisplayed = false;  
        let lastCategory = null;  
  
        // --- Utility Functions ---  
        function adjustZoom(delta) {  
            currentZoom = Math.max(1, Math.min(20, currentZoom + delta)); // Max zoom is now 20  
            artImageElement.style.transform = `scale(${currentZoom})`;  
        }  
  
        function toggleLoading(show) {  
            loadingElement.style.display = show ? 'block' : 'none';  
            skeletonElement.style.display = show ? 'block' : 'none';  
            artImageElement.style.display = show ? 'none' : 'block';  
            imageContentElement.style.opacity = show ? 0.5 : 1;  
        }  
  
        function showError(message) {  
            errorMessageElement.textContent = message;  
            errorMessageElement.classList.add('show');  
            errorMessageElement.style.display = 'flex'; // Ensure it's displayed as flex  
  
            setTimeout(() => {  
                errorMessageElement.classList.remove('show');  
                setTimeout(() => {  
                    errorMessageElement.style.display = 'none'; // Hide after fade out  
                }, transitionDuration * 1000);  
            }, 3000);  
        }  
  
  
        // --- Image Fetching and Preloading ---  
        const fetchedImageDataCache = new Map();  
  
        async function fetchImageData(apiSource, category) {  
            const cacheKey = `${apiSource}-${category}`;  
            if (fetchedImageDataCache.has(cacheKey)) {  
                return fetchedImageDataCache.get(cacheKey);  
            }  
  
            let apiUrl = '';  
            let imageUrl = '';  
            let isWaifuPics = false;  
            let isNekosMoe = false;  
            let apiCategory = category;  
  
            if (apiSource === 'waifu_pics_api') {  
                isWaifuPics = true;  
                apiCategory = category.substring(6);  
                apiUrl = `${apiEndpoints.waifu_pics_api}${apiCategory}`;  
            } else if (apiSource === 'nsfw_api') {  
                apiUrl = `${apiEndpoints.nsfw_api}${category}`;  
                isWaifuPics = false;  
            } else if (apiSource === 'nekos_moe_api') {  
                apiUrl = `${apiEndpoints.nekos_moe_api}?count=1&nsfw=true`;  
                isNekosMoe = true;  
            } else {  
                throw new Error(`Unknown API source: ${apiSource}`);  
            }  
  
            try {  
                const response = await fetch(apiUrl);  
                if (!response.ok) {  
                    throw new Error(`Image fetch failed with status: ${response.status} - ${response.statusText}`);  
                }  
                const data = await response.json();  
  
                if (isWaifuPics) {  
                    imageUrl = data.url;  
                } else if (isNekosMoe && data.images && data.images.length > 0) {  
                    imageUrl = `https://nekos.moe/image/${data.images[0].id}.jpg`;  
                } else if (!isWaifuPics && !isNekosMoe) {  
                    imageUrl = data.url_japan;  
                } else {  
                    throw new Error('Invalid API response format');  
                }  
  
                fetchedImageDataCache.set(cacheKey, imageUrl);  
                return imageUrl;  
            } catch (error) {  
                console.error("Error fetching image data:", error);  
                throw error;  
            }  
        }  
  
  
        async function preloadImages() {  
            if (isPreloading) return;  
            isPreloading = true;  
            const preloadPromises = [];  
  
            while (preloadQueue.length < preloadQueueLimit && preloadPromises.length < preloadQueueLimit) {  
                const randomApiSource = apiSources[Math.floor(Math.random() * apiSources.length)];  
                let randomCategory = null;  
  
                if (randomApiSource !== 'nekos_moe_api') {  
                    if (randomApiSource === 'waifu_pics_api') {  
                         randomCategory = `waifu_${waifuPicsApiCategories[Math.floor(Math.random() * waifuPicsApiCategories.length)]}`;  
                    } else {  
                        randomCategory = nsfwApiCategories[Math.floor(Math.random() * nsfwApiCategories.length)];  
                    }  
                }  
  
                const preloadPromise = fetchImageData(randomApiSource, randomCategory)  
                    .then(imageUrl => {  
                        if (imageUrl) {  
                            return { url: imageUrl, apiSource: randomApiSource, category: randomCategory };  
                        }  
                        return null;  
                    })  
                    .catch(error => {  
                        console.error("Preload fetch failed for API source:", randomApiSource, "Category:", randomCategory, error);  
                        return null;  
                    });  
                preloadPromises.push(preloadPromise);  
            }  
  
            Promise.all(preloadPromises)  
            .then(results => {  
                results.filter(result => result != null).forEach(imageInfo => {  
                    if (preloadQueue.findIndex(item => item.url === imageInfo.url) === -1 && !displayedImageUrls.has(imageInfo.url)) {  
                        const image = new Image();  
                        image.src = imageInfo.url;  
                        image.loading = 'lazy';  
                        image.onload = () => {  
                            preloadQueue.push(imageInfo);  
                            if (preloadQueue.length >= preloadQueueLimit) {  
                                isPreloading = false;  
                                if (pendingDisplay) {  
                                    pendingDisplay = false;  
                                    displayNewImage();  
                                }  
                            }  
                        };  
                        image.onerror = () => {  
                            console.error("Error preloading image from:", imageInfo.url);  
                        };  
                    }  
                });  
                isPreloading = false;  
                if (pendingDisplay && preloadQueue.length >= 1) {  
                    pendingDisplay = false;  
                    displayNewImage();  
                }  
                if (preloadQueue.length < preloadQueueLimit) {  
                    preloadImages();  
                }  
            })  
            .catch(error => {  
                console.error("Error in preloadImages Promise.all:", error);  
                isPreloading = false;  
            });  
        }  
  
  
        async function displayNewImage() {  
            if (isLoading) {  
                pendingDisplay = true;  
                return;  
            }  
            if (!initialImageDisplayed) {  
                skeletonElement.style.animationDuration = '1s';  
                loadingElement.style.animationDuration = '1s';  
            } else {  
                skeletonElement.style.animationDuration = '2s';  
                loadingElement.style.animationDuration = '2s';  
            }  
  
            if (preloadQueue.length === 0 && !isPreloading) {  
                pendingDisplay = true;  
                preloadImages();  
                return;  
            }  
  
            isLoading = true;  
            toggleLoading(true);  
            imageContentElement.style.transition = `opacity ${transitionDuration}s ease`;  
            imageContentElement.style.opacity = 0;  
  
            let imageInfo;  
            let imageUrl, imageCategory, imageApiSource;  
            let attempts = 0;  
            const maxAttempts = 10;  
  
            while (attempts < maxAttempts) {  
                attempts++;  
                imageInfo = preloadQueue.shift();  
                if (imageInfo) {  
                    imageUrl = imageInfo.url;  
                    imageCategory = imageInfo.category;  
                    imageApiSource = imageInfo.apiSource;  
                    if (!displayedImageUrls.has(imageUrl)) {  
                        break;  
                    } else {  
                        console.log("Skipping duplicate image:", imageUrl);  
                        imageInfo = null;  
                    }  
                } else {  
                    break;  
                }  
            }  
  
            if (!imageInfo) {  
                const fallbackApiSource = apiSources[Math.floor(Math.random() * apiSources.length)];  
                let fallbackCategory = null;  
                if (fallbackApiSource !== 'nekos_moe_api') {  
                    if (fallbackApiSource === 'waifu_pics_api') {  
                         fallbackCategory = `waifu_${waifuPicsApiCategories[Math.floor(Math.random() * waifuPicsApiCategories.length)]}`;  
                    } else {  
                        fallbackCategory = nsfwApiCategories[Math.floor(Math.random() * nsfwApiCategories.length)];  
                    }  
                }  
  
                try {  
                    imageUrl = await fetchImageData(fallbackApiSource, fallbackCategory);  
                    imageCategory = fallbackCategory;  
                    imageApiSource = fallbackApiSource;  
                     if (displayedImageUrls.has(imageUrl)) {  
                        toggleLoading(false);  
                        isLoading = false;  
                        showError('Failed to load unique artwork. Please try again later.');  
                        return;  
                    }  
                } catch (fetchError) {  
                    toggleLoading(false);  
                    isLoading = false;  
                    showError('Failed to load artwork. Please try again later.');  
                    return;  
                }  
            }  
            lastCategory = imageCategory;  
  
            setTimeout(async () => {  
                artImageElement.onload = () => {  
                    currentZoom = 1;  
                    artImageElement.style.transform = `scale(${currentZoom})`;  
                    nekoWrapper.style.aspectRatio = `${artImageElement.naturalWidth}/${artImageElement.naturalHeight}`;  
                    toggleLoading(false);  
                    isLoading = false;  
                    imageContentElement.style.opacity = 1;  
                    initialImageDisplayed = true;  
                    displayedImageUrls.add(imageUrl);  
                    if (preloadQueue.length > preloadQueueLimit * 2) {  
                        preloadQueue.splice(0, preloadQueue.length - preloadQueueLimit);  
                    }  
  
                    if (!isPreloading && preloadQueue.length < preloadQueueLimit) {  
                        preloadImages();  
                    }  
                };  
  
                artImageElement.onerror = () => {  
                    displayNewImage(); // Retry on image load error, no error message on image load fail as it's handled by retry  
                };  
  
                artImageElement.src = imageUrl;  
            }, transitionDuration * 1000);  
        }  
  
  
        // --- Event Listeners ---  
        newArtButton.addEventListener('click', displayNewImage);  
        zoomInButton.addEventListener('click', () => adjustZoom(0.05)); // Finer zoom increment  
        zoomOutButton.addEventListener('click', () => adjustZoom(-0.05)); // Finer zoom increment  
  
        // --- Initial Setup ---  
        displayNewImage();  
        preloadImages();  
    });  
</script>  </body>  
</html>

Implement an infinite scroll feature for the website gallery with the following behavior:

Trigger Condition:

When a user scrolls near the end of the gallery, or

When a user selects a category and reaches the end of the currently loaded images for that category.


Action:

Dynamically insert 10 loading image placeholders into the gallery.

Concurrently, fetch an additional 10 images from the API corresponding to the user’s selected category.


Important Constraint:

Under no circumstances should any API endpoints or functionalities be modified or disrupted.



Ensure smooth, uninterrupted user experience while strictly preserving all existing API integrations.

make the system so like the images get displayed as their original full size (for example - portrait kind of images must not be displayed as landscape, and landscapes must not be displayed as portrait, all should be displayed in their original size, anywhere on the website) also remove image specific name and description completely, and fix this error.